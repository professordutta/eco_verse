<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EcoSort 3D - Recycling Arcade Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        
        .ui-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .score-panel {
            text-align: left;
        }
        
        .info-panel {
            text-align: right;
        }
        
        .score {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .level, .speed, .lives {
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .lives {
            color: #f44336;
        }
        
                    #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 14px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .game-over-title {
            font-size: 36px;
            color: #f44336;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .final-score {
            font-size: 24px;
            color: #4CAF50;
            margin-bottom: 30px;
        }
        
        .restart-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .combo-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            opacity: 0;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div class="ui-panel score-panel">
                <div class="score">Score: <span id="score">0</span></div>
                <div class="level">Level: <span id="level">1</span></div>
                <div class="lives">Lives: <span id="lives">3</span></div>
            </div>
            <div class="ui-panel info-panel">
                <div class="speed">Speed: <span id="speed">1.0x</span></div>
                <div>Combo: <span id="combo">0</span></div>
                <div>Streak: <span id="streak">0</span></div>
            </div>
        </div>
        
        <div id="instructions">
            Drag trash items from the conveyor belt to the correct bins behind it: ðŸŸ¦ Paper | ðŸŸ© Glass | ðŸŸ¨ Plastic
        </div>
        
        <div id="gameOver">
            <div class="game-over-title">Game Over!</div>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        </div>
        
        <div class="combo-display" id="comboDisplay"></div>
    </div>

    <script>
        // Game variables
        let scene, camera, renderer, raycaster, mouse;
        let conveyor, bins = [], trashItems = [], particles = [];
        let gameState = {
            score: 0,
            level: 1,
            lives: 5,
            speed: 1.0,
            combo: 0,
            streak: 0,
            gameOver: false,
            paused: false
        };
        let piledTrash = [];
        let selectedObject = null;
        let dragOffset = new THREE.Vector3();
        let trashSpawnTimer = 0;
        let levelTimer = 0;
        
        // Trash types with colors and materials
        const trashTypes = {
            plastic: { color: 0xFFEB3B, binIndex: 2, name: 'Plastic', emissive: 0x332900 },
            paper: { color: 0x2196F3, binIndex: 0, name: 'Paper', emissive: 0x001a33 },
            glass: { color: 0x4CAF50, binIndex: 1, name: 'Glass', emissive: 0x0d2818 }
        };
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            // Create factory background
            createFactoryBackground();
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0xff6b6b, 0.5, 30);
            pointLight1.position.set(-10, 8, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4ecdc4, 0.5, 30);
            pointLight2.position.set(10, 8, 5);
            scene.add(pointLight2);
            
            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createEnvironment();
            createBins();
            setupEventListeners();
            
            // Start the game loop
            animate();
        }
        
        function createEnvironment() {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(40, 30);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d3748,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Conveyor belt - much wider and lower barriers
            const conveyorGeometry = new THREE.BoxGeometry(20, 0.5, 6);
            const conveyorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a5568,
                shininess: 30
            });
            conveyor = new THREE.Mesh(conveyorGeometry, conveyorMaterial);
            conveyor.position.set(0, 0, 0);
            conveyor.castShadow = true;
            conveyor.receiveShadow = true;
            scene.add(conveyor);
            
            // Conveyor belt texture movement - wider belt
            const beltGeometry = new THREE.PlaneGeometry(20, 6);
            const beltTexture = createBeltTexture();
            const beltMaterial = new THREE.MeshPhongMaterial({ 
                map: beltTexture,
                transparent: true,
                opacity: 0.9
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.rotation.x = -Math.PI / 2;
            belt.position.set(0, 0.26, 0);
            scene.add(belt);
            conveyor.beltTexture = beltTexture;
            
            // Much lower side barriers
            const barrierGeometry = new THREE.BoxGeometry(20, 0.5, 0.2);
            const barrierMaterial = new THREE.MeshPhongMaterial({ color: 0x2d3748 });
            
            const barrier1 = new THREE.Mesh(barrierGeometry, barrierMaterial);
            barrier1.position.set(0, 0.5, 3.1);
            barrier1.castShadow = true;
            scene.add(barrier1);
            
            const barrier2 = new THREE.Mesh(barrierGeometry, barrierMaterial);
            barrier2.position.set(0, 0.5, -3.1);
            barrier2.castShadow = true;
            scene.add(barrier2);
            
            // Generator box on the left
            createGeneratorBox();
        }
        
        function createBeltTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Create a repeating pattern for the belt
            ctx.fillStyle = '#4a5568';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 2;
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = 4;
            return texture;
        }
        
        function createFactoryBackground() {
            // Set industrial background color
            scene.background = new THREE.Color(0x2c3e50);
            scene.fog = new THREE.Fog(0x2c3e50, 60, 200);
            
            // Factory walls - positioned far from game area
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x34495e,
                transparent: true,
                opacity: 0.7
            });
            
            // Back wall - far behind
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 30),
                wallMaterial
            );
            backWall.position.set(0, 12, -40);
            backWall.receiveShadow = false; // Don't receive shadows
            scene.add(backWall);
            
            // Side walls - positioned far to sides
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 30),
                wallMaterial
            );
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-40, 12, 0);
            leftWall.receiveShadow = false;
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 30),
                wallMaterial
            );
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(40, 12, 0);
            rightWall.receiveShadow = false;
            scene.add(rightWall);
            
            // High factory ceiling
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2c3e50,
                transparent: true,
                opacity: 0.4
            });
            const ceiling = new THREE.Mesh(
                new THREE.PlaneGeometry(80, 80),
                ceilingMaterial
            );
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(0, 25, 0);
            ceiling.receiveShadow = false;
            scene.add(ceiling);
            
            // Industrial beams - high up and don't cast shadows
            const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x7f8c8d });
            for (let i = -30; i <= 30; i += 15) {
                const beam = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 1.5, 80),
                    beamMaterial
                );
                beam.position.set(i, 23, 0);
                beam.castShadow = false; // Don't cast shadows
                beam.receiveShadow = false;
                scene.add(beam);
            }
            
            // Distant support columns - positioned outside game area
            const columnPositions = [
                [-35, -30], [-35, 30], [35, -30], [35, 30],
                [-25, -35], [25, -35], [-25, 35], [25, 35]
            ];
            
            columnPositions.forEach(([x, z]) => {
                const column = new THREE.Mesh(
                    new THREE.CylinderGeometry(1, 1.2, 25),
                    beamMaterial
                );
                column.position.set(x, 12.5, z);
                column.castShadow = false; // Don't cast shadows
                column.receiveShadow = false;
                scene.add(column);
            });
            
            // Factory pipes on back wall
            const pipeMaterial = new THREE.MeshLambertMaterial({ color: 0x95a5a6 });
            for (let i = 0; i < 6; i++) {
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 60),
                    pipeMaterial
                );
                pipe.rotation.z = Math.PI / 2;
                pipe.position.set(-25 + i * 10, 18 + (i % 2) * 2, -39);
                pipe.castShadow = false;
                pipe.receiveShadow = false;
                scene.add(pipe);
            }
            
            // Industrial vents on ceiling - no shadows
            const ventMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x7f8c8d,
                emissive: 0x222222,
                emissiveIntensity: 0.2
            });
            for (let i = 0; i < 4; i++) {
                const vent = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2, 0.8),
                    ventMaterial
                );
                vent.position.set(-20 + i * 13, 24, -10 + (i % 2) * 20);
                vent.castShadow = false;
                vent.receiveShadow = false;
                scene.add(vent);
            }
            
            // Factory signs on distant walls
            createFactorySign(-35, 15, -25, 'âš ï¸ DANGER\nHIGH VOLTAGE', true);
            createFactorySign(35, 15, 25, 'â™»ï¸ RECYCLING\nFACILITY', true);
            createFactorySign(0, 20, -39, 'ðŸ­ WASTE PROCESSING PLANT #7', false);
            
            // Ambient industrial lighting - positioned high and away from game area
            for (let i = -30; i <= 30; i += 20) {
                for (let j = -30; j <= 30; j += 20) {
                    if (Math.abs(i) < 20 && Math.abs(j) < 20) continue; // Skip game area
                    
                    const lightFixture = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.5, 2, 1.5),
                        new THREE.MeshLambertMaterial({ 
                            color: 0x2c3e50,
                            emissive: 0x333333,
                            emissiveIntensity: 0.3
                        })
                    );
                    lightFixture.position.set(i, 22, j);
                    lightFixture.castShadow = false;
                    lightFixture.receiveShadow = false;
                    scene.add(lightFixture);
                    
                    // Soft ambient light - doesn't cast shadows
                    const factoryLight = new THREE.PointLight(0x4a6fa5, 0.3, 40);
                    factoryLight.position.set(i, 21, j);
                    factoryLight.castShadow = false; // Explicitly no shadows
                    scene.add(factoryLight);
                }
            }
            
            // Add subtle steam effects in distance
            createDistantSteamEffects();
        }
        
        function createFactorySign(x, y, z, text, isOnSideWall) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Sign background
            ctx.fillStyle = '#f39c12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#e67e22';
            ctx.lineWidth = 8;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Sign text
            ctx.fillStyle = '#000';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            
            const lines = text.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, canvas.width / 2, 100 + index * 45);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshLambertMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const geometry = new THREE.PlaneGeometry(10, 5);
            const sign = new THREE.Mesh(geometry, material);
            sign.position.set(x, y, z);
            sign.castShadow = false;
            sign.receiveShadow = false;
            
            if (isOnSideWall) {
                sign.rotation.y = x > 0 ? -Math.PI / 2 : Math.PI / 2;
            }
            
            scene.add(sign);
        }
        
        function createDistantSteamEffects() {
            const steamMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.2
            });
            
            // Create steam clouds in the distance
            for (let i = 0; i < 12; i++) {
                const steam = new THREE.Mesh(
                    new THREE.SphereGeometry(2 + Math.random() * 2, 8, 8),
                    steamMaterial
                );
                steam.position.set(
                    -35 + Math.random() * 70,
                    20 + Math.random() * 8,
                    -35 + Math.random() * 20 // Keep in background
                );
                steam.castShadow = false;
                steam.receiveShadow = false;
                steam.userData = {
                    originalY: steam.position.y,
                    floatSpeed: 0.3 + Math.random() * 0.4
                };
                scene.add(steam);
                
                // Animate steam floating
                function animateSteam() {
                    steam.position.y = steam.userData.originalY + Math.sin(Date.now() * 0.001 * steam.userData.floatSpeed) * 3;
                    steam.rotation.y += 0.003;
                    requestAnimationFrame(animateSteam);
                }
                animateSteam();
            }
        }
        
        function createGeneratorBox() {
            // Main generator box body
            const boxGeometry = new THREE.BoxGeometry(4, 4, 5);
            const boxMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x34495e,
                shininess: 30
            });
            const generatorBox = new THREE.Mesh(boxGeometry, boxMaterial);
            generatorBox.position.set(-13, 2, 0);
            generatorBox.castShadow = true;
            generatorBox.receiveShadow = true;
            scene.add(generatorBox);
            
            // Generator box top with slight angle
            const topGeometry = new THREE.BoxGeometry(4.2, 0.3, 5.2);
            const topMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                shininess: 50
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.set(-13, 4.15, 0);
            top.castShadow = true;
            scene.add(top);
            
            // Output chute connecting to conveyor
            const chuteGeometry = new THREE.BoxGeometry(2, 1, 3);
            const chuteMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                shininess: 30
            });
            const chute = new THREE.Mesh(chuteGeometry, chuteMaterial);
            chute.position.set(-10.5, 1, 0);
            chute.castShadow = true;
            scene.add(chute);
            
            // Add some details - control panel
            const panelGeometry = new THREE.BoxGeometry(1.5, 1.5, 0.2);
            const panelMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a252f,
                shininess: 80
            });
            const panel = new THREE.Mesh(panelGeometry, panelMaterial);
            panel.position.set(-13, 2.5, 2.6);
            scene.add(panel);
            
            // Warning light on top
            const lightGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.3, 8);
            const lightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff6b6b,
                emissive: 0x330000,
                emissiveIntensity: 0.3
            });
            const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
            warningLight.position.set(-13, 4.5, 1);
            scene.add(warningLight);
            
            // Make the warning light blink
            let blinkTime = 0;
            function animateWarningLight() {
                blinkTime += 0.05;
                const intensity = Math.sin(blinkTime * 3) * 0.3 + 0.3;
                warningLight.material.emissiveIntensity = Math.max(0.1, intensity);
                requestAnimationFrame(animateWarningLight);
            }
            animateWarningLight();
            
            // Add generator label
            createGeneratorLabel(-13, 5.5, 0, 'TRASH GENERATOR');
        }
        
        function createBins() {
            const binPositions = [
                { x: -12, z: -6, color: 0x2196F3, label: 'Paper' },
                { x: 0, z: -6, color: 0x4CAF50, label: 'Glass' },
                { x: 12, z: -6, color: 0xFFEB3B, label: 'Plastic' }
            ];
            
            binPositions.forEach((pos, index) => {
                // Bin body - much larger
                const binGeometry = new THREE.CylinderGeometry(2.5, 3, 4.5, 16);
                const binMaterial = new THREE.MeshPhongMaterial({ 
                    color: pos.color,
                    shininess: 50,
                    transparent: true,
                    opacity: 0.8
                });
                const bin = new THREE.Mesh(binGeometry, binMaterial);
                bin.position.set(pos.x, 2.25, pos.z);
                bin.castShadow = true;
                bin.receiveShadow = true;
                bin.userData = { type: 'bin', index: index, label: pos.label };
                scene.add(bin);
                bins.push(bin);
                
                // Bin lid - larger
                const lidGeometry = new THREE.CylinderGeometry(2.7, 2.7, 0.3, 16);
                const lidMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(pos.color).multiplyScalar(0.7),
                    shininess: 80
                });
                const lid = new THREE.Mesh(lidGeometry, lidMaterial);
                lid.position.set(pos.x, 4.65, pos.z);
                lid.castShadow = true;
                scene.add(lid);
                
                // Label - positioned better
                createBinLabel(pos.x, 6, pos.z, pos.label);
            });
        }
        
        function createBinLabel(x, y, z, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true
            });
            const geometry = new THREE.PlaneGeometry(4, 1);
            const label = new THREE.Mesh(geometry, material);
            label.position.set(x, y, z);
            label.lookAt(camera.position);
            scene.add(label);
        }
        
        function createGeneratorLabel(x, y, z, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(52, 73, 94, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ecf0f1';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, 42);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true
            });
            const geometry = new THREE.PlaneGeometry(6, 1.5);
            const label = new THREE.Mesh(geometry, material);
            label.position.set(x, y, z);
            label.lookAt(camera.position);
            scene.add(label);
        }
        
        function createTrashItem() {
            const types = Object.keys(trashTypes);
            const type = types[Math.floor(Math.random() * types.length)];
            const trashData = trashTypes[type];
            
            // Create different shapes for different trash types - all larger
            let geometry;
            switch(type) {
                case 'plastic':
                    geometry = new THREE.CylinderGeometry(0.6, 0.6, 1.8, 8); // Larger bottle
                    break;
                case 'paper':
                    geometry = new THREE.BoxGeometry(1.5, 0.15, 2); // Larger paper
                    break;
                case 'glass':
                    geometry = new THREE.SphereGeometry(0.75, 12, 8); // Larger jar
                    break;
            }
            
            const material = new THREE.MeshPhongMaterial({
                color: trashData.color,
                shininess: type === 'glass' ? 100 : 30,
                emissive: trashData.emissive,
                emissiveIntensity: 0.1
            });
            
            const trash = new THREE.Mesh(geometry, material);
            // Position on the conveyor belt surface (0.25 is belt surface height + object height/2)
            trash.position.set(-11, 0.8, (Math.random() - 0.5) * 4.5); // Start near generator, on belt surface
            trash.castShadow = true;
            trash.receiveShadow = true;
            trash.userData = { 
                type: 'trash', 
                trashType: type, 
                correctBin: trashData.binIndex,
                speed: 2 + gameState.level * 0.5
            };
            
            // Add some rotation for visual appeal
            trash.rotation.set(
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2,
                Math.random() * Math.PI * 2
            );
            
            scene.add(trash);
            trashItems.push(trash);
            
            // Add particle effect when spawning from generator
            createSpawnParticles(trash.position);
        }
        
        function createSpawnParticles(position) {
            const particleCount = 15;
            const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 3 + 1,
                    (Math.random() - 0.5) * 4
                );
                particle.life = 1.0;
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createSuccessParticles(position, color) {
            const particleCount = 25;
            const particleGeometry = new THREE.SphereGeometry(0.08, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: color });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 6,
                    Math.random() * 4 + 2,
                    (Math.random() - 0.5) * 6
                );
                particle.life = 1.5;
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createFailureParticles(position) {
            const particleCount = 15;
            const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 2 + 1,
                    (Math.random() - 0.5) * 3
                );
                particle.life = 1.0;
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                particle.velocity.y -= 0.2; // Gravity
                particle.life -= 0.016;
                
                particle.material.opacity = particle.life;
                particle.scale.setScalar(particle.life);
                
                if (particle.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }
        
        function setupEventListeners() {
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
        }
        
        function onMouseDown(event) {
            if (gameState.gameOver) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(trashItems);
            
            if (intersects.length > 0) {
                selectedObject = intersects[0].object;
                // Simplified drag offset - just use a fixed height offset
                dragOffset.set(0, 1, 0);
                
                // Visual feedback
                selectedObject.scale.setScalar(1.2);
                selectedObject.material.emissiveIntensity = 0.3;
            }
        }
        
        function onMouseMove(event) {
            if (gameState.gameOver) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            if (selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                // Use a plane at ground level for easier dragging
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectPoint = new THREE.Vector3();
                
                if (raycaster.ray.intersectPlane(groundPlane, intersectPoint)) {
                    // Move object to mouse position with height suitable for dragging
                    selectedObject.position.x = intersectPoint.x;
                    selectedObject.position.z = intersectPoint.z;
                    selectedObject.position.y = 1.5; // Slightly elevated when dragging
                    
                    // Constrain to reasonable bounds
                    selectedObject.position.x = Math.max(-15, Math.min(15, selectedObject.position.x));
                    selectedObject.position.z = Math.max(-8, Math.min(4, selectedObject.position.z));
                }
            }
        }
        
        function onMouseUp(event) {
            if (gameState.gameOver || !selectedObject) return;
            
            // Check if dropped in a bin
            let droppedInBin = false;
            let correctBin = false;
            
            bins.forEach((bin, index) => {
                const distance = selectedObject.position.distanceTo(bin.position);
                
                if (distance < 5) { // Detection radius
                    droppedInBin = true;
                    correctBin = (index === selectedObject.userData.correctBin);
                    
                    if (correctBin) {
                        // Correct bin! Move object inside the bin
                        const points = (gameState.combo + 1) * 10;
                        gameState.score += points;
                        gameState.combo++;
                        gameState.streak++;
                        
                        // Position object inside the bin
                        selectedObject.position.copy(bin.position);
                        selectedObject.position.y = bin.position.y - 1.5; // Inside the bin
                        selectedObject.position.x += (Math.random() - 0.5) * 1.5; // Random offset
                        selectedObject.position.z += (Math.random() - 0.5) * 1.5; // Random offset
                        
                        // Scale down the object slightly
                        selectedObject.scale.setScalar(0.8);
                        
                        // Make it less bright to show it's "stored"
                        selectedObject.material.emissiveIntensity = 0.05;
                        
                        // Mark it as sorted so it won't move with conveyor
                        selectedObject.userData.sorted = true;
                        
                        // Create success particles
                        createSuccessParticles(bin.position, bin.material.color);
                        
                        // Show combo if high enough
                        if (gameState.combo >= 3) {
                            showCombo(gameState.combo);
                        }
                        
                        // Animate bin
                        animateBin(bin);
                        
                        // Remove from active trash items but keep in scene
                        const trashIndex = trashItems.indexOf(selectedObject);
                        if (trashIndex > -1) {
                            trashItems.splice(trashIndex, 1);
                        }
                        
                    } else {
                        // Wrong bin!
                        gameState.lives--;
                        gameState.combo = 0;
                        gameState.streak = 0;
                        
                        // Create failure effect
                        bin.material.emissive.setHex(0x660000);
                        setTimeout(() => {
                            bin.material.emissive.setHex(0x000000);
                        }, 200);
                        
                        if (gameState.lives <= 0) {
                            endGame();
                            return;
                        }
                        
                        // Still remove incorrectly sorted items
                        scene.remove(selectedObject);
                        const trashIndex = trashItems.indexOf(selectedObject);
                        if (trashIndex > -1) {
                            trashItems.splice(trashIndex, 1);
                        }
                    }
                }
            });
            
            if (!droppedInBin) {
                // Return to conveyor if not dropped in a bin
                selectedObject.position.y = 0.8; // On belt surface
                selectedObject.position.x = Math.max(-10, Math.min(10, selectedObject.position.x));
                selectedObject.position.z = Math.max(-2.5, Math.min(2.5, selectedObject.position.z));
            }
            
            // Reset visual effects
            if (selectedObject) {
                selectedObject.scale.setScalar(selectedObject.userData.sorted ? 0.8 : 1);
                selectedObject.material.emissiveIntensity = selectedObject.userData.sorted ? 0.05 : 0.1;
                selectedObject = null;
            }
            
            updateUI();
        }
        
        function animateBin(bin) {
            const originalY = bin.position.y;
            const jumpHeight = 0.5;
            const jumpDuration = 300;
            let startTime = Date.now();
            
            function jump() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / jumpDuration, 1);
                const height = Math.sin(progress * Math.PI) * jumpHeight;
                bin.position.y = originalY + height;
                
                if (progress < 1) {
                    requestAnimationFrame(jump);
                } else {
                    bin.position.y = originalY;
                }
            }
            jump();
        }
        
        function showCombo(combo) {
            const display = document.getElementById('comboDisplay');
            display.textContent = `${combo}x COMBO!`;
            display.style.opacity = '1';
            display.style.transform = 'translate(-50%, -50%) scale(1.5)';
            
            setTimeout(() => {
                display.style.opacity = '0';
                display.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 1000);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('speed').textContent = gameState.speed.toFixed(1) + 'x';
            document.getElementById('combo').textContent = gameState.combo;
            document.getElementById('streak').textContent = gameState.streak;
        }
        
        function updateGameLogic(deltaTime) {
            if (gameState.gameOver) return;
            
            // Move trash items along conveyor
            for (let i = trashItems.length - 1; i >= 0; i--) {
                const trash = trashItems[i];
                if (trash === selectedObject || trash.userData.sorted) continue; // Skip if being dragged or already sorted
                
                trash.position.x += trash.userData.speed * gameState.speed * deltaTime;
                
                // Rotate for visual appeal
                trash.rotation.x += deltaTime * 2;
                trash.rotation.z += deltaTime * 1.5;
                
                // Pile up at the right end instead of removing
                if (trash.position.x > 10) {
                    // Move to pile area and add to piled trash
                    const pileHeight = Math.floor(piledTrash.length / 8) * 1.2; // Stack height
                    const pilePosition = piledTrash.length % 8; // Position in current layer
                    
                    trash.position.x = 11 + (pilePosition % 4) * 0.8; // X position in pile
                    trash.position.z = -1 + Math.floor(pilePosition / 4) * 0.8; // Z position in pile
                    trash.position.y = 0.8 + pileHeight; // Y position (stacked)
                    
                    // Stop rotation and scale down slightly
                    trash.rotation.set(0, 0, 0);
                    trash.scale.setScalar(0.9);
                    
                    // Make it look "dumped"
                    trash.material.emissiveIntensity = 0.05;
                    
                    // Mark as piled and move to piled array
                    trash.userData.piled = true;
                    piledTrash.push(trash);
                    trashItems.splice(i, 1);
                    
                    // Lose life for letting trash pile up
                    gameState.lives--;
                    gameState.combo = 0;
                    
                    // Create "failure" particles at pile
                    createFailureParticles(trash.position);
                    
                    if (gameState.lives <= 0) {
                        endGame();
                        return;
                    }
                }
            }
            
            // Spawn new trash
            trashSpawnTimer += deltaTime;
            const spawnRate = Math.max(0.5, 2 - gameState.level * 0.1);
            if (trashSpawnTimer > spawnRate) {
                createTrashItem();
                trashSpawnTimer = 0;
            }
            
            // Level progression
            levelTimer += deltaTime;
            if (levelTimer > 30) { // Level up every 30 seconds
                gameState.level++;
                gameState.speed = Math.min(3.0, 1.0 + gameState.level * 0.1);
                levelTimer = 0;
            }
            
            // Animate conveyor belt
            if (conveyor.beltTexture) {
                conveyor.beltTexture.offset.x += deltaTime * gameState.speed * 0.5;
            }
            
            updateUI();
        }
        
        function endGame() {
            gameState.gameOver = true;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            gameState = {
                score: 0,
                level: 1,
                lives: 5,
                speed: 1.0,
                combo: 0,
                streak: 0,
                gameOver: false,
                paused: false
            };
            
            // Clear existing trash items and piled trash
            trashItems.forEach(trash => scene.remove(trash));
            trashItems = [];
            
            piledTrash.forEach(trash => scene.remove(trash));
            piledTrash = [];
            
            // Clear particles
            particles.forEach(particle => scene.remove(particle));
            particles = [];
            
            // Reset timers
            trashSpawnTimer = 0;
            levelTimer = 0;
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset selected object
            selectedObject = null;
            
            updateUI();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updateGameLogic(deltaTime);
            updateParticles();
            
            renderer.render(scene, camera);
        }
        
        // Start the game
        init();
    </script>
</body>
</html>